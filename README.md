# PulseScope

PulseScope 是一款专为 RoboMaster 视觉算法开发设计的高性能、非侵入式实时调试系统。

其软件架构采用了 “三层解耦、内存中转、网页渲染” 的工业级设计模型，确保在不干扰算法效率的前提下，提供极致的调试体验。

## 1. 核心数据流向 (The Data Pipeline)
整个系统通过 Linux 共享内存 (`/dev/shm`) 作为高速中转站，实现跨进程的数据交换：
- **生产端 (NUC 内部)**：C++ 算法主循环执行 `memcpy`。
- **中转端 (NUC 内部)**：Go 后端执行 `mmap` 读取。
- **展示端 (局域网)**：浏览器执行 WebSocket/HTTP 渲染。

## 2. 三层架构详细设计

### 第一层：PulseScope Producer (C++ Header-only 库)
- **形态**：轻量级头文件库，直接集成到自瞄生产代码中。
- **核心职责**：
    - **图像暴露**：将每一帧处理后的调试图（JPG 编码）写入共享内存。
    - **变量导出**：将 EKF 状态、目标位姿、PID 误差等变量序列化为 JSON 写入内存。
    - **串口镜像**：实时记录串口收发的每一包原始字节，解决“串口黑盒”痛点。
    - **参数同步**：每一帧开始时检查参数内存块，实现动态调参。

### 第二层：PulseScope Bridge (Go Backend Service)
- **形态**：独立运行的 Go 后台服务进程。
- **核心职责**：
    - **高性能读取**：利用 `mmap` 零拷贝读取共享内存，实现微秒级数据获取。
    - **数据分路**：
        - **视频流**：封装为 MJPEG 流提供给前端。
        - **数值流**：通过 WebSocket 实时广播波形数据。
        - **命令流**：接收前端调参指令并回写至内存。
    - **协议解析**：借鉴 asuwave 的 SLIP 协议，确保串口通信在干扰环境下依然稳健。

### 第三层：PulseScope Monitor (Web Frontend)
- **形态**：基于 Vue/React 的现代 Web 交互界面。
- **核心职责**：
    - **渲染卸载**：利用笔记本电脑的 CPU/GPU 进行复杂的图表绘制（Chart.js），完全不占用机器人 NUC 的算力。
    - **逻辑可视化**：提供可折叠的 JSON 树状视图，实时展示串口协议包细节。
    - **实时示波器**：支持多通道波形对比（如：视觉指令值 vs. 电控反馈值）。

## 3. 系统核心优势
- **高内聚低耦合**：模块间仅通过 “内存契约” (`shm_layout.hpp`) 连接。算法、后端、前端均可独立迭代。
- **非侵入式开发**：通过 Header-only 设计，只需要在 `auto_aim.cpp` 里增加几行代码，即可开启强大的监控窗口。
- **通信透明化**：将原本看不见的串口比特流转化成网页上直观的波形和日志，快速定位通信问题。
- **极高性能**：数据传输链路基于内存拷贝而非网络套接字，自瞄主循环的延迟增加几乎为零。

## 4. 工程化标准
- **代码规范**：统一遵循 `Clang-format-19` 格式标准。
- **自动化校验**：集成 `lint.sh` 和 Git 钩子。
- **模拟模式**：支持 `Mock Mode`，在无硬件环境下通过脚本模拟共享内存数据，确保前后端开发并行。